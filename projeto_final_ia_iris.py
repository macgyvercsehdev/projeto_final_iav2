# -*- coding: utf-8 -*-
"""Projeto Final - IA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xpSLPSTxA2e5vE3O_6E2vuZXUw8ESohe
"""

'''
João Victor Bandeira dos Anjos, João Victor Ferreira Gomes, Luiz Fernando Ferreira Messias Ribeiro, Macgyver Cseh dos Santos, Wellington Gomes da Silva 
'''
#importando as bibliotecas do scikit-learn
from sklearn.tree import DecisionTreeClassifier, export_graphviz
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.model_selection import train_test_split
#importando as bibliotecas de manipulações matemáticas, plotagem gráfica e manipulações de matrizes
import numpy as np 
import itertools
import pandas as pd
import matplotlib.pyplot as plt
from six import StringIO
import pydotplus
from IPython.display import Image

#Conforme solicitado no primeiro tópico, esse é o método de importação do dataframe
df = pd.read_excel('iris.xlsx') 
# Abaixo demonstraremos como a tabela está estruturada
print(df.head(5))
count_row = df.shape[0] #Com esse comando demonstramos o número de registros
count_col = df.shape[1] #Com esse comando demonstramos o número de colunas 
print('-'*60)
print('Quantidade de linhas = ' , count_row)
print('Quantidade de colunas = ',count_col)

#Aqui excluiremos os registros que estão em branco.
#O dataframe utilizado não possuia registros nulos, mas essa é uma fase importante do tratamento do banco
#antes da aplicação de um méodo de aprendizado de máquina, por isso decidimos deixá-lo no código 
df = df.dropna()

print(df.head(5))
print('-'*60)
print('Quantidade de linhas - após a exclusão dos nulos = ' , count_row)
print('Quantidade de colunas - após a exclusão dos nulos = ',count_col)

#Abaixo olharemos se o dataset está balanceado
print('-'*60)
print('Total de registros iguais a Setosa: ', df[df['variedade'] =='Setosa'].shape[0])
print('Total de registros iguais a Versicolor: ', df[df['variedade'] =='Versicolor'].shape[0])
print('Total de registros iguais a Versicolor: ', df[df['variedade'] =='Virgínia'].shape[0])

#Jogando as etiquetas para Y
Y = df['variedade'].values 
print(Y)
#Declarando a nossa matriz com as features
X = df[['sépala.comprimento', 'sépala.largura', 'pétala.comprimento','pétala.largura']].values
print(X)

#No comando abaixo realizamos as divisão do dataset em treino e teste, no nosso exemplo a divisão, respectivamente, foi de 80 e 20%
X_treino, X_teste, Y_treino, Y_teste = train_test_split(X, Y, test_size=0.2, random_state=3)

#A seguir criamos a arvore de decisão, colocando como parâmetro o critério de entropia e tamanho máximo da árvore
algortimo_arvore = DecisionTreeClassifier(criterion='entropy', max_depth=7)


#Na sequência treinaremos a árvore
modelo = algortimo_arvore.fit(X_treino, Y_treino)

#Printando a árvore
print(modelo.feature_importances_)


nome_features = ['sépala.comprimento', 'sépala.largura', 'pétala.comprimento','pétala.largura']
nome_classes = modelo.classes_

#Montando a árvore
dot_data = StringIO()
export_graphviz(modelo, out_file=dot_data, filled=True, feature_names=nome_features, class_names=nome_classes, rounded=True, special_characters=True)
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
Image(graph.create_png())
graph.write_png("arvore.png")
Image('arvore.png')

#Armazenando em Y_predicoes a base de teste
Y_predicoes = modelo.predict(X_teste)

#Verificando a acurácia do modelo
print("ACURÁCIA DA ÁRVORE: ", accuracy_score(Y_teste, Y_predicoes))

#Plotando a matriz de confusão
def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):

    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Matriz de Confusão Normalizada")
    else:
        print('Matriz de Confusão sem normalizacão ')

    print(cm)

    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, cm[i, j],
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")

    plt.tight_layout()
    plt.ylabel('Rótulo real')
    plt.xlabel('Rótulo prevista')

matrix_confusao = confusion_matrix(Y_teste, Y_predicoes)
plt.figure()
plot_confusion_matrix(matrix_confusao, classes=nome_classes,
                      title='Matrix de Confusao')